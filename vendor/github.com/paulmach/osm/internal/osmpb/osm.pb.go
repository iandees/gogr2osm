// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: osm.proto

/*
	Package osmpb is a generated protocol buffer package.

	It is generated from these files:
		osm.proto

	It has these top-level messages:
		Changeset
		Bounds
		Change
		Tags
		OSM
		Node
		Info
		DenseNodes
		DenseInfo
		Way
		Relation
		DenseMembers
*/
package osmpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Relation_MemberType int32

const (
	Relation_NODE     Relation_MemberType = 0
	Relation_WAY      Relation_MemberType = 1
	Relation_RELATION Relation_MemberType = 2
)

var Relation_MemberType_name = map[int32]string{
	0: "NODE",
	1: "WAY",
	2: "RELATION",
}
var Relation_MemberType_value = map[string]int32{
	"NODE":     0,
	"WAY":      1,
	"RELATION": 2,
}

func (x Relation_MemberType) Enum() *Relation_MemberType {
	p := new(Relation_MemberType)
	*p = x
	return p
}
func (x Relation_MemberType) String() string {
	return proto.EnumName(Relation_MemberType_name, int32(x))
}
func (x *Relation_MemberType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Relation_MemberType_value, data, "Relation_MemberType")
	if err != nil {
		return err
	}
	*x = Relation_MemberType(value)
	return nil
}
func (Relation_MemberType) EnumDescriptor() ([]byte, []int) { return fileDescriptorOsm, []int{10, 0} }

type Changeset struct {
	Id *int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Parallel arrays.
	Keys      []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals      []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	UserId    *int32   `protobuf:"varint,5,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	UserSid   *uint32  `protobuf:"varint,6,opt,name=user_sid,json=userSid" json:"user_sid,omitempty"`
	CreatedAt *int64   `protobuf:"varint,7,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	ClosedAt  *int64   `protobuf:"varint,8,opt,name=closed_at,json=closedAt" json:"closed_at,omitempty"`
	Open      *bool    `protobuf:"varint,9,opt,name=open" json:"open,omitempty"`
	Bounds    *Bounds  `protobuf:"bytes,10,opt,name=bounds" json:"bounds,omitempty"`
	Change    *Change  `protobuf:"bytes,11,opt,name=change" json:"change,omitempty"`
	// contains the tag strings for everything
	// in this entire changeset.
	Strings []string `protobuf:"bytes,20,rep,name=strings" json:"strings,omitempty"`
}

func (m *Changeset) Reset()                    { *m = Changeset{} }
func (m *Changeset) String() string            { return proto.CompactTextString(m) }
func (*Changeset) ProtoMessage()               {}
func (*Changeset) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{0} }

func (m *Changeset) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Changeset) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Changeset) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Changeset) GetUserId() int32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *Changeset) GetUserSid() uint32 {
	if m != nil && m.UserSid != nil {
		return *m.UserSid
	}
	return 0
}

func (m *Changeset) GetCreatedAt() int64 {
	if m != nil && m.CreatedAt != nil {
		return *m.CreatedAt
	}
	return 0
}

func (m *Changeset) GetClosedAt() int64 {
	if m != nil && m.ClosedAt != nil {
		return *m.ClosedAt
	}
	return 0
}

func (m *Changeset) GetOpen() bool {
	if m != nil && m.Open != nil {
		return *m.Open
	}
	return false
}

func (m *Changeset) GetBounds() *Bounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *Changeset) GetChange() *Change {
	if m != nil {
		return m.Change
	}
	return nil
}

func (m *Changeset) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Bounds struct {
	MinLon int64 `protobuf:"zigzag64,1,req,name=min_lon,json=minLon" json:"min_lon"`
	MaxLon int64 `protobuf:"zigzag64,2,req,name=max_lon,json=maxLon" json:"max_lon"`
	MinLat int64 `protobuf:"zigzag64,3,req,name=min_lat,json=minLat" json:"min_lat"`
	MaxLat int64 `protobuf:"zigzag64,4,req,name=max_lat,json=maxLat" json:"max_lat"`
}

func (m *Bounds) Reset()                    { *m = Bounds{} }
func (m *Bounds) String() string            { return proto.CompactTextString(m) }
func (*Bounds) ProtoMessage()               {}
func (*Bounds) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{1} }

func (m *Bounds) GetMinLon() int64 {
	if m != nil {
		return m.MinLon
	}
	return 0
}

func (m *Bounds) GetMaxLon() int64 {
	if m != nil {
		return m.MaxLon
	}
	return 0
}

func (m *Bounds) GetMinLat() int64 {
	if m != nil {
		return m.MinLat
	}
	return 0
}

func (m *Bounds) GetMaxLat() int64 {
	if m != nil {
		return m.MaxLat
	}
	return 0
}

type Change struct {
	Create *OSM `protobuf:"bytes,1,opt,name=create" json:"create,omitempty"`
	Modify *OSM `protobuf:"bytes,2,opt,name=modify" json:"modify,omitempty"`
	Delete *OSM `protobuf:"bytes,3,opt,name=delete" json:"delete,omitempty"`
	// elements that give the change extra context like
	// nodes of the ways, and previous versions.
	Context *OSM `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
	// contains the tag strings if this is the root of the data.
	Strings []string `protobuf:"bytes,20,rep,name=strings" json:"strings,omitempty"`
}

func (m *Change) Reset()                    { *m = Change{} }
func (m *Change) String() string            { return proto.CompactTextString(m) }
func (*Change) ProtoMessage()               {}
func (*Change) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{2} }

func (m *Change) GetCreate() *OSM {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *Change) GetModify() *OSM {
	if m != nil {
		return m.Modify
	}
	return nil
}

func (m *Change) GetDelete() *OSM {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *Change) GetContext() *OSM {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Change) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Tags struct {
	// encoded as [key1, val1, key2, val2, etc.]
	KeysVals []string `protobuf:"bytes,1,rep,name=keys_vals,json=keysVals" json:"keys_vals,omitempty"`
}

func (m *Tags) Reset()                    { *m = Tags{} }
func (m *Tags) String() string            { return proto.CompactTextString(m) }
func (*Tags) ProtoMessage()               {}
func (*Tags) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{3} }

func (m *Tags) GetKeysVals() []string {
	if m != nil {
		return m.KeysVals
	}
	return nil
}

type OSM struct {
	Bounds *Bounds `protobuf:"bytes,1,opt,name=bounds" json:"bounds,omitempty"`
	// an encoded should have either nodes or a dense_nodes, but not both.
	Nodes      []*Node     `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty"`
	DenseNodes *DenseNodes `protobuf:"bytes,3,opt,name=dense_nodes,json=denseNodes" json:"dense_nodes,omitempty"`
	Ways       []*Way      `protobuf:"bytes,4,rep,name=ways" json:"ways,omitempty"`
	Relations  []*Relation `protobuf:"bytes,5,rep,name=relations" json:"relations,omitempty"`
	// contains the tag strings if this is the root of the data.
	Strings []string `protobuf:"bytes,15,rep,name=strings" json:"strings,omitempty"`
}

func (m *OSM) Reset()                    { *m = OSM{} }
func (m *OSM) String() string            { return proto.CompactTextString(m) }
func (*OSM) ProtoMessage()               {}
func (*OSM) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{4} }

func (m *OSM) GetBounds() *Bounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *OSM) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *OSM) GetDenseNodes() *DenseNodes {
	if m != nil {
		return m.DenseNodes
	}
	return nil
}

func (m *OSM) GetWays() []*Way {
	if m != nil {
		return m.Ways
	}
	return nil
}

func (m *OSM) GetRelations() []*Relation {
	if m != nil {
		return m.Relations
	}
	return nil
}

func (m *OSM) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Node struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	Lat  int64    `protobuf:"zigzag64,8,req,name=lat" json:"lat"`
	Lon  int64    `protobuf:"zigzag64,9,req,name=lon" json:"lon"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{5} }

func (m *Node) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Node) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Node) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Node) GetLat() int64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *Node) GetLon() int64 {
	if m != nil {
		return m.Lon
	}
	return 0
}

type Info struct {
	Version   int32 `protobuf:"varint,1,opt,name=version" json:"version"`
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp"`
	// these can be omitted if the object represents one changeset
	// since they will be all the same. However tests on 200k changesets
	// show this saves about 17 bytes per changeset on average after gzip.
	ChangesetId int64  `protobuf:"varint,3,opt,name=changeset_id,json=changesetId" json:"changeset_id"`
	UserId      int32  `protobuf:"varint,4,opt,name=user_id,json=userId" json:"user_id"`
	UserSid     uint32 `protobuf:"varint,5,opt,name=user_sid,json=userSid" json:"user_sid"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API. This info may be omitted if it can be inferred from its group
	// ie. create, modify, delete.
	Visible *bool `protobuf:"varint,6,opt,name=visible" json:"visible,omitempty"`
	// the time this element was committed into the db. Could be much later than
	// timestamp for large uploads.
	Committed *int64 `protobuf:"varint,7,opt,name=committed" json:"committed,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{6} }

func (m *Info) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Info) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Info) GetChangesetId() int64 {
	if m != nil {
		return m.ChangesetId
	}
	return 0
}

func (m *Info) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Info) GetUserSid() uint32 {
	if m != nil {
		return m.UserSid
	}
	return 0
}

func (m *Info) GetVisible() bool {
	if m != nil && m.Visible != nil {
		return *m.Visible
	}
	return false
}

func (m *Info) GetCommitted() int64 {
	if m != nil && m.Committed != nil {
		return *m.Committed
	}
	return 0
}

type DenseNodes struct {
	Ids       []int64    `protobuf:"zigzag64,1,rep,packed,name=ids" json:"ids,omitempty"`
	DenseInfo *DenseInfo `protobuf:"bytes,5,opt,name=dense_info,json=denseInfo" json:"dense_info,omitempty"`
	Lats      []int64    `protobuf:"zigzag64,8,rep,packed,name=lats" json:"lats,omitempty"`
	Lons      []int64    `protobuf:"zigzag64,9,rep,packed,name=lons" json:"lons,omitempty"`
	// Special packing of keys and vals into one array. We use a single stringid
	// of 0 to delimit when the tags of a node ends and the tags of the next node
	// begin. The storage pattern is: ((<keyid> <valid>)* '0' )* As an exception,
	// if no node in the current block has any key/value pairs, this array does
	// not contain any delimiters, but is simply empty.
	KeysVals []uint32 `protobuf:"varint,10,rep,packed,name=keys_vals,json=keysVals" json:"keys_vals,omitempty"`
	Strings  []string `protobuf:"bytes,15,rep,name=strings" json:"strings,omitempty"`
}

func (m *DenseNodes) Reset()                    { *m = DenseNodes{} }
func (m *DenseNodes) String() string            { return proto.CompactTextString(m) }
func (*DenseNodes) ProtoMessage()               {}
func (*DenseNodes) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{7} }

func (m *DenseNodes) GetIds() []int64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *DenseNodes) GetDenseInfo() *DenseInfo {
	if m != nil {
		return m.DenseInfo
	}
	return nil
}

func (m *DenseNodes) GetLats() []int64 {
	if m != nil {
		return m.Lats
	}
	return nil
}

func (m *DenseNodes) GetLons() []int64 {
	if m != nil {
		return m.Lons
	}
	return nil
}

func (m *DenseNodes) GetKeysVals() []uint32 {
	if m != nil {
		return m.KeysVals
	}
	return nil
}

func (m *DenseNodes) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type DenseInfo struct {
	Versions   []int32 `protobuf:"varint,1,rep,packed,name=versions" json:"versions,omitempty"`
	Timestamps []int64 `protobuf:"zigzag64,2,rep,packed,name=timestamps" json:"timestamps,omitempty"`
	// these will be omitted if the object represents one changeset
	// and these will be all the same.
	ChangesetIds []int64 `protobuf:"zigzag64,3,rep,packed,name=changeset_ids,json=changesetIds" json:"changeset_ids,omitempty"`
	UserIds      []int32 `protobuf:"zigzag32,4,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
	UserSids     []int32 `protobuf:"zigzag32,5,rep,packed,name=user_sids,json=userSids" json:"user_sids,omitempty"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API. This info may be omitted if it can be inferred from its group
	// ie. create, modify, delete.
	Visibles []bool `protobuf:"varint,6,rep,packed,name=visibles" json:"visibles,omitempty"`
	// the time this element was committed into the db. Could be much later than
	// timestamp for large uploads.
	Committeds []int64 `protobuf:"zigzag64,7,rep,packed,name=committeds" json:"committeds,omitempty"`
}

func (m *DenseInfo) Reset()                    { *m = DenseInfo{} }
func (m *DenseInfo) String() string            { return proto.CompactTextString(m) }
func (*DenseInfo) ProtoMessage()               {}
func (*DenseInfo) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{8} }

func (m *DenseInfo) GetVersions() []int32 {
	if m != nil {
		return m.Versions
	}
	return nil
}

func (m *DenseInfo) GetTimestamps() []int64 {
	if m != nil {
		return m.Timestamps
	}
	return nil
}

func (m *DenseInfo) GetChangesetIds() []int64 {
	if m != nil {
		return m.ChangesetIds
	}
	return nil
}

func (m *DenseInfo) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *DenseInfo) GetUserSids() []int32 {
	if m != nil {
		return m.UserSids
	}
	return nil
}

func (m *DenseInfo) GetVisibles() []bool {
	if m != nil {
		return m.Visibles
	}
	return nil
}

func (m *DenseInfo) GetCommitteds() []int64 {
	if m != nil {
		return m.Committeds
	}
	return nil
}

type Way struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	// Only one of the next two must be included.
	// refs are DELTA coded node ids. If there is more info,
	// versions, changeset ids, lat and lon will be encoded
	// as a DenseMembers object.
	Refs         []int64       `protobuf:"zigzag64,8,rep,packed,name=refs" json:"refs,omitempty"`
	DenseMembers *DenseMembers `protobuf:"bytes,9,opt,name=dense_members,json=denseMembers" json:"dense_members,omitempty"`
	// updates are changes to members that did not happen
	// at a similar time to a change in the parent.
	Updates *DenseMembers `protobuf:"bytes,10,opt,name=updates" json:"updates,omitempty"`
}

func (m *Way) Reset()                    { *m = Way{} }
func (m *Way) String() string            { return proto.CompactTextString(m) }
func (*Way) ProtoMessage()               {}
func (*Way) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{9} }

func (m *Way) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Way) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Way) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Way) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Way) GetRefs() []int64 {
	if m != nil {
		return m.Refs
	}
	return nil
}

func (m *Way) GetDenseMembers() *DenseMembers {
	if m != nil {
		return m.DenseMembers
	}
	return nil
}

func (m *Way) GetUpdates() *DenseMembers {
	if m != nil {
		return m.Updates
	}
	return nil
}

type Relation struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	// Parallel arrays
	// Roles has been changed int32 -> uint32 form the osm proto,
	// this is for consistency and backwards compatible.
	Roles []uint32              `protobuf:"varint,8,rep,packed,name=roles" json:"roles,omitempty"`
	Refs  []int64               `protobuf:"zigzag64,9,rep,packed,name=refs" json:"refs,omitempty"`
	Types []Relation_MemberType `protobuf:"varint,10,rep,packed,name=types,enum=osm.Relation_MemberType" json:"types,omitempty"`
	// DenseMembers includes annotated information about the members
	DenseMembers *DenseMembers `protobuf:"bytes,11,opt,name=dense_members,json=denseMembers" json:"dense_members,omitempty"`
	// updates are changes to members that did not happen
	// at a similar time to a change in the parent.
	Updates *DenseMembers `protobuf:"bytes,12,opt,name=updates" json:"updates,omitempty"`
}

func (m *Relation) Reset()                    { *m = Relation{} }
func (m *Relation) String() string            { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()               {}
func (*Relation) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{10} }

func (m *Relation) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Relation) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Relation) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Relation) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Relation) GetRoles() []uint32 {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *Relation) GetRefs() []int64 {
	if m != nil {
		return m.Refs
	}
	return nil
}

func (m *Relation) GetTypes() []Relation_MemberType {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Relation) GetDenseMembers() *DenseMembers {
	if m != nil {
		return m.DenseMembers
	}
	return nil
}

func (m *Relation) GetUpdates() *DenseMembers {
	if m != nil {
		return m.Updates
	}
	return nil
}

type DenseMembers struct {
	Indexes      []int32 `protobuf:"zigzag32,1,rep,packed,name=indexes" json:"indexes,omitempty"`
	Versions     []int32 `protobuf:"varint,2,rep,packed,name=versions" json:"versions,omitempty"`
	Timestamps   []int64 `protobuf:"zigzag64,3,rep,packed,name=timestamps" json:"timestamps,omitempty"`
	ChangesetIds []int64 `protobuf:"zigzag64,4,rep,packed,name=changeset_ids,json=changesetIds" json:"changeset_ids,omitempty"`
	Orientation  []int32 `protobuf:"zigzag32,5,rep,packed,name=orientation" json:"orientation,omitempty"`
	// included if some of the members are nodes
	Lats []int64 `protobuf:"zigzag64,8,rep,packed,name=lats" json:"lats,omitempty"`
	Lons []int64 `protobuf:"zigzag64,9,rep,packed,name=lons" json:"lons,omitempty"`
}

func (m *DenseMembers) Reset()                    { *m = DenseMembers{} }
func (m *DenseMembers) String() string            { return proto.CompactTextString(m) }
func (*DenseMembers) ProtoMessage()               {}
func (*DenseMembers) Descriptor() ([]byte, []int) { return fileDescriptorOsm, []int{11} }

func (m *DenseMembers) GetIndexes() []int32 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *DenseMembers) GetVersions() []int32 {
	if m != nil {
		return m.Versions
	}
	return nil
}

func (m *DenseMembers) GetTimestamps() []int64 {
	if m != nil {
		return m.Timestamps
	}
	return nil
}

func (m *DenseMembers) GetChangesetIds() []int64 {
	if m != nil {
		return m.ChangesetIds
	}
	return nil
}

func (m *DenseMembers) GetOrientation() []int32 {
	if m != nil {
		return m.Orientation
	}
	return nil
}

func (m *DenseMembers) GetLats() []int64 {
	if m != nil {
		return m.Lats
	}
	return nil
}

func (m *DenseMembers) GetLons() []int64 {
	if m != nil {
		return m.Lons
	}
	return nil
}

func init() {
	proto.RegisterType((*Changeset)(nil), "osm.Changeset")
	proto.RegisterType((*Bounds)(nil), "osm.Bounds")
	proto.RegisterType((*Change)(nil), "osm.Change")
	proto.RegisterType((*Tags)(nil), "osm.Tags")
	proto.RegisterType((*OSM)(nil), "osm.OSM")
	proto.RegisterType((*Node)(nil), "osm.Node")
	proto.RegisterType((*Info)(nil), "osm.Info")
	proto.RegisterType((*DenseNodes)(nil), "osm.DenseNodes")
	proto.RegisterType((*DenseInfo)(nil), "osm.DenseInfo")
	proto.RegisterType((*Way)(nil), "osm.Way")
	proto.RegisterType((*Relation)(nil), "osm.Relation")
	proto.RegisterType((*DenseMembers)(nil), "osm.DenseMembers")
	proto.RegisterEnum("osm.Relation_MemberType", Relation_MemberType_name, Relation_MemberType_value)
}
func (m *Changeset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Changeset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOsm(dAtA, i, uint64(*m.Id))
	}
	if len(m.Keys) > 0 {
		dAtA2 := make([]byte, len(m.Keys)*10)
		var j1 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Vals) > 0 {
		dAtA4 := make([]byte, len(m.Vals)*10)
		var j3 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.UserId != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOsm(dAtA, i, uint64(*m.UserId))
	}
	if m.UserSid != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOsm(dAtA, i, uint64(*m.UserSid))
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOsm(dAtA, i, uint64(*m.CreatedAt))
	}
	if m.ClosedAt != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOsm(dAtA, i, uint64(*m.ClosedAt))
	}
	if m.Open != nil {
		dAtA[i] = 0x48
		i++
		if *m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Bounds != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Bounds.Size()))
		n5, err := m.Bounds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Change != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Change.Size()))
		n6, err := m.Change.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Bounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bounds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MinLon)<<1)^uint64((m.MinLon>>63))))
	dAtA[i] = 0x10
	i++
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MaxLon)<<1)^uint64((m.MaxLon>>63))))
	dAtA[i] = 0x18
	i++
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MinLat)<<1)^uint64((m.MinLat>>63))))
	dAtA[i] = 0x20
	i++
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MaxLat)<<1)^uint64((m.MaxLat>>63))))
	return i, nil
}

func (m *Change) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Change) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Create != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Create.Size()))
		n7, err := m.Create.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Modify != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Modify.Size()))
		n8, err := m.Modify.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Delete != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Delete.Size()))
		n9, err := m.Delete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Context != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Context.Size()))
		n10, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Tags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tags) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeysVals) > 0 {
		for _, s := range m.KeysVals {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *OSM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSM) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bounds != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Bounds.Size()))
		n11, err := m.Bounds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOsm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DenseNodes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.DenseNodes.Size()))
		n12, err := m.DenseNodes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Ways) > 0 {
		for _, msg := range m.Ways {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOsm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Relations) > 0 {
		for _, msg := range m.Relations {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOsm(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.Id))
	if len(m.Keys) > 0 {
		dAtA14 := make([]byte, len(m.Keys)*10)
		var j13 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.Vals) > 0 {
		dAtA16 := make([]byte, len(m.Vals)*10)
		var j15 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.Info != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Info.Size()))
		n17, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.Lat)<<1)^uint64((m.Lat>>63))))
	dAtA[i] = 0x48
	i++
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.Lon)<<1)^uint64((m.Lon>>63))))
	return i, nil
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.Version))
	dAtA[i] = 0x10
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.Timestamp))
	dAtA[i] = 0x18
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.ChangesetId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.UserId))
	dAtA[i] = 0x28
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.UserSid))
	if m.Visible != nil {
		dAtA[i] = 0x30
		i++
		if *m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Committed != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOsm(dAtA, i, uint64(*m.Committed))
	}
	return i, nil
}

func (m *DenseNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseNodes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		var j18 int
		dAtA20 := make([]byte, len(m.Ids)*10)
		for _, num := range m.Ids {
			x19 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x19 >= 1<<7 {
				dAtA20[j18] = uint8(uint64(x19)&0x7f | 0x80)
				j18++
				x19 >>= 7
			}
			dAtA20[j18] = uint8(x19)
			j18++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA20[:j18])
	}
	if m.DenseInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.DenseInfo.Size()))
		n21, err := m.DenseInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Lats) > 0 {
		var j22 int
		dAtA24 := make([]byte, len(m.Lats)*10)
		for _, num := range m.Lats {
			x23 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x23 >= 1<<7 {
				dAtA24[j22] = uint8(uint64(x23)&0x7f | 0x80)
				j22++
				x23 >>= 7
			}
			dAtA24[j22] = uint8(x23)
			j22++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA24[:j22])
	}
	if len(m.Lons) > 0 {
		var j25 int
		dAtA27 := make([]byte, len(m.Lons)*10)
		for _, num := range m.Lons {
			x26 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x26 >= 1<<7 {
				dAtA27[j25] = uint8(uint64(x26)&0x7f | 0x80)
				j25++
				x26 >>= 7
			}
			dAtA27[j25] = uint8(x26)
			j25++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA27[:j25])
	}
	if len(m.KeysVals) > 0 {
		dAtA29 := make([]byte, len(m.KeysVals)*10)
		var j28 int
		for _, num := range m.KeysVals {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DenseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Versions) > 0 {
		dAtA31 := make([]byte, len(m.Versions)*10)
		var j30 int
		for _, num1 := range m.Versions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	if len(m.Timestamps) > 0 {
		var j32 int
		dAtA34 := make([]byte, len(m.Timestamps)*10)
		for _, num := range m.Timestamps {
			x33 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x33 >= 1<<7 {
				dAtA34[j32] = uint8(uint64(x33)&0x7f | 0x80)
				j32++
				x33 >>= 7
			}
			dAtA34[j32] = uint8(x33)
			j32++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA34[:j32])
	}
	if len(m.ChangesetIds) > 0 {
		var j35 int
		dAtA37 := make([]byte, len(m.ChangesetIds)*10)
		for _, num := range m.ChangesetIds {
			x36 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x36 >= 1<<7 {
				dAtA37[j35] = uint8(uint64(x36)&0x7f | 0x80)
				j35++
				x36 >>= 7
			}
			dAtA37[j35] = uint8(x36)
			j35++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA37[:j35])
	}
	if len(m.UserIds) > 0 {
		dAtA38 := make([]byte, len(m.UserIds)*5)
		var j39 int
		for _, num := range m.UserIds {
			x40 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x40 >= 1<<7 {
				dAtA38[j39] = uint8(uint64(x40)&0x7f | 0x80)
				j39++
				x40 >>= 7
			}
			dAtA38[j39] = uint8(x40)
			j39++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA38[:j39])
	}
	if len(m.UserSids) > 0 {
		dAtA41 := make([]byte, len(m.UserSids)*5)
		var j42 int
		for _, num := range m.UserSids {
			x43 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x43 >= 1<<7 {
				dAtA41[j42] = uint8(uint64(x43)&0x7f | 0x80)
				j42++
				x43 >>= 7
			}
			dAtA41[j42] = uint8(x43)
			j42++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j42))
		i += copy(dAtA[i:], dAtA41[:j42])
	}
	if len(m.Visibles) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOsm(dAtA, i, uint64(len(m.Visibles)))
		for _, b := range m.Visibles {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Committeds) > 0 {
		var j44 int
		dAtA46 := make([]byte, len(m.Committeds)*10)
		for _, num := range m.Committeds {
			x45 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x45 >= 1<<7 {
				dAtA46[j44] = uint8(uint64(x45)&0x7f | 0x80)
				j44++
				x45 >>= 7
			}
			dAtA46[j44] = uint8(x45)
			j44++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j44))
		i += copy(dAtA[i:], dAtA46[:j44])
	}
	return i, nil
}

func (m *Way) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Way) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.Id))
	if len(m.Keys) > 0 {
		dAtA48 := make([]byte, len(m.Keys)*10)
		var j47 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j47))
		i += copy(dAtA[i:], dAtA48[:j47])
	}
	if len(m.Vals) > 0 {
		dAtA50 := make([]byte, len(m.Vals)*10)
		var j49 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j49))
		i += copy(dAtA[i:], dAtA50[:j49])
	}
	if m.Info != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Info.Size()))
		n51, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.Refs) > 0 {
		var j52 int
		dAtA54 := make([]byte, len(m.Refs)*10)
		for _, num := range m.Refs {
			x53 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x53 >= 1<<7 {
				dAtA54[j52] = uint8(uint64(x53)&0x7f | 0x80)
				j52++
				x53 >>= 7
			}
			dAtA54[j52] = uint8(x53)
			j52++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j52))
		i += copy(dAtA[i:], dAtA54[:j52])
	}
	if m.DenseMembers != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.DenseMembers.Size()))
		n55, err := m.DenseMembers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.Updates != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Updates.Size()))
		n56, err := m.Updates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintOsm(dAtA, i, uint64(m.Id))
	if len(m.Keys) > 0 {
		dAtA58 := make([]byte, len(m.Keys)*10)
		var j57 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j57))
		i += copy(dAtA[i:], dAtA58[:j57])
	}
	if len(m.Vals) > 0 {
		dAtA60 := make([]byte, len(m.Vals)*10)
		var j59 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j59))
		i += copy(dAtA[i:], dAtA60[:j59])
	}
	if m.Info != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Info.Size()))
		n61, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if len(m.Roles) > 0 {
		dAtA63 := make([]byte, len(m.Roles)*10)
		var j62 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j62))
		i += copy(dAtA[i:], dAtA63[:j62])
	}
	if len(m.Refs) > 0 {
		var j64 int
		dAtA66 := make([]byte, len(m.Refs)*10)
		for _, num := range m.Refs {
			x65 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x65 >= 1<<7 {
				dAtA66[j64] = uint8(uint64(x65)&0x7f | 0x80)
				j64++
				x65 >>= 7
			}
			dAtA66[j64] = uint8(x65)
			j64++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j64))
		i += copy(dAtA[i:], dAtA66[:j64])
	}
	if len(m.Types) > 0 {
		dAtA68 := make([]byte, len(m.Types)*10)
		var j67 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA68[j67] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j67++
			}
			dAtA68[j67] = uint8(num)
			j67++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j67))
		i += copy(dAtA[i:], dAtA68[:j67])
	}
	if m.DenseMembers != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.DenseMembers.Size()))
		n69, err := m.DenseMembers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.Updates != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOsm(dAtA, i, uint64(m.Updates.Size()))
		n70, err := m.Updates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}

func (m *DenseMembers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseMembers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		dAtA71 := make([]byte, len(m.Indexes)*5)
		var j72 int
		for _, num := range m.Indexes {
			x73 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x73 >= 1<<7 {
				dAtA71[j72] = uint8(uint64(x73)&0x7f | 0x80)
				j72++
				x73 >>= 7
			}
			dAtA71[j72] = uint8(x73)
			j72++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j72))
		i += copy(dAtA[i:], dAtA71[:j72])
	}
	if len(m.Versions) > 0 {
		dAtA75 := make([]byte, len(m.Versions)*10)
		var j74 int
		for _, num1 := range m.Versions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA75[j74] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j74++
			}
			dAtA75[j74] = uint8(num)
			j74++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j74))
		i += copy(dAtA[i:], dAtA75[:j74])
	}
	if len(m.Timestamps) > 0 {
		var j76 int
		dAtA78 := make([]byte, len(m.Timestamps)*10)
		for _, num := range m.Timestamps {
			x77 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x77 >= 1<<7 {
				dAtA78[j76] = uint8(uint64(x77)&0x7f | 0x80)
				j76++
				x77 >>= 7
			}
			dAtA78[j76] = uint8(x77)
			j76++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j76))
		i += copy(dAtA[i:], dAtA78[:j76])
	}
	if len(m.ChangesetIds) > 0 {
		var j79 int
		dAtA81 := make([]byte, len(m.ChangesetIds)*10)
		for _, num := range m.ChangesetIds {
			x80 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x80 >= 1<<7 {
				dAtA81[j79] = uint8(uint64(x80)&0x7f | 0x80)
				j79++
				x80 >>= 7
			}
			dAtA81[j79] = uint8(x80)
			j79++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j79))
		i += copy(dAtA[i:], dAtA81[:j79])
	}
	if len(m.Orientation) > 0 {
		dAtA82 := make([]byte, len(m.Orientation)*5)
		var j83 int
		for _, num := range m.Orientation {
			x84 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x84 >= 1<<7 {
				dAtA82[j83] = uint8(uint64(x84)&0x7f | 0x80)
				j83++
				x84 >>= 7
			}
			dAtA82[j83] = uint8(x84)
			j83++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j83))
		i += copy(dAtA[i:], dAtA82[:j83])
	}
	if len(m.Lats) > 0 {
		var j85 int
		dAtA87 := make([]byte, len(m.Lats)*10)
		for _, num := range m.Lats {
			x86 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x86 >= 1<<7 {
				dAtA87[j85] = uint8(uint64(x86)&0x7f | 0x80)
				j85++
				x86 >>= 7
			}
			dAtA87[j85] = uint8(x86)
			j85++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j85))
		i += copy(dAtA[i:], dAtA87[:j85])
	}
	if len(m.Lons) > 0 {
		var j88 int
		dAtA90 := make([]byte, len(m.Lons)*10)
		for _, num := range m.Lons {
			x89 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x89 >= 1<<7 {
				dAtA90[j88] = uint8(uint64(x89)&0x7f | 0x80)
				j88++
				x89 >>= 7
			}
			dAtA90[j88] = uint8(x89)
			j88++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOsm(dAtA, i, uint64(j88))
		i += copy(dAtA[i:], dAtA90[:j88])
	}
	return i, nil
}

func encodeFixed64Osm(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Osm(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintOsm(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Changeset) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovOsm(uint64(*m.Id))
	}
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.UserId != nil {
		n += 1 + sovOsm(uint64(*m.UserId))
	}
	if m.UserSid != nil {
		n += 1 + sovOsm(uint64(*m.UserSid))
	}
	if m.CreatedAt != nil {
		n += 1 + sovOsm(uint64(*m.CreatedAt))
	}
	if m.ClosedAt != nil {
		n += 1 + sovOsm(uint64(*m.ClosedAt))
	}
	if m.Open != nil {
		n += 2
	}
	if m.Bounds != nil {
		l = m.Bounds.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 2 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Bounds) Size() (n int) {
	var l int
	_ = l
	n += 1 + sozOsm(uint64(m.MinLon))
	n += 1 + sozOsm(uint64(m.MaxLon))
	n += 1 + sozOsm(uint64(m.MinLat))
	n += 1 + sozOsm(uint64(m.MaxLat))
	return n
}

func (m *Change) Size() (n int) {
	var l int
	_ = l
	if m.Create != nil {
		l = m.Create.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Modify != nil {
		l = m.Modify.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 2 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Tags) Size() (n int) {
	var l int
	_ = l
	if len(m.KeysVals) > 0 {
		for _, s := range m.KeysVals {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *OSM) Size() (n int) {
	var l int
	_ = l
	if m.Bounds != nil {
		l = m.Bounds.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if m.DenseNodes != nil {
		l = m.DenseNodes.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Ways) > 0 {
		for _, e := range m.Ways {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	n += 1 + sozOsm(uint64(m.Lat))
	n += 1 + sozOsm(uint64(m.Lon))
	return n
}

func (m *Info) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Version))
	n += 1 + sovOsm(uint64(m.Timestamp))
	n += 1 + sovOsm(uint64(m.ChangesetId))
	n += 1 + sovOsm(uint64(m.UserId))
	n += 1 + sovOsm(uint64(m.UserSid))
	if m.Visible != nil {
		n += 2
	}
	if m.Committed != nil {
		n += 1 + sovOsm(uint64(*m.Committed))
	}
	return n
}

func (m *DenseNodes) Size() (n int) {
	var l int
	_ = l
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.DenseInfo != nil {
		l = m.DenseInfo.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Lats) > 0 {
		l = 0
		for _, e := range m.Lats {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Lons) > 0 {
		l = 0
		for _, e := range m.Lons {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.KeysVals) > 0 {
		l = 0
		for _, e := range m.KeysVals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *DenseInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Versions) > 0 {
		l = 0
		for _, e := range m.Versions {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Timestamps) > 0 {
		l = 0
		for _, e := range m.Timestamps {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.ChangesetIds) > 0 {
		l = 0
		for _, e := range m.ChangesetIds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.UserSids) > 0 {
		l = 0
		for _, e := range m.UserSids {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Visibles) > 0 {
		n += 1 + sovOsm(uint64(len(m.Visibles))) + len(m.Visibles)*1
	}
	if len(m.Committeds) > 0 {
		l = 0
		for _, e := range m.Committeds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	return n
}

func (m *Way) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Refs) > 0 {
		l = 0
		for _, e := range m.Refs {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.DenseMembers != nil {
		l = m.DenseMembers.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Updates != nil {
		l = m.Updates.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Refs) > 0 {
		l = 0
		for _, e := range m.Refs {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.DenseMembers != nil {
		l = m.DenseMembers.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Updates != nil {
		l = m.Updates.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	return n
}

func (m *DenseMembers) Size() (n int) {
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		l = 0
		for _, e := range m.Indexes {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Versions) > 0 {
		l = 0
		for _, e := range m.Versions {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Timestamps) > 0 {
		l = 0
		for _, e := range m.Timestamps {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.ChangesetIds) > 0 {
		l = 0
		for _, e := range m.ChangesetIds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Orientation) > 0 {
		l = 0
		for _, e := range m.Orientation {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Lats) > 0 {
		l = 0
		for _, e := range m.Lats {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Lons) > 0 {
		l = 0
		for _, e := range m.Lons {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	return n
}

func sovOsm(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOsm(x uint64) (n int) {
	return sovOsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Changeset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Changeset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Changeset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserId = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserSid = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreatedAt = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedAt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClosedAt = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Open = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bounds == nil {
				m.Bounds = &Bounds{}
			}
			if err := m.Bounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &Change{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bounds) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MinLon = int64(v)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MaxLon = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MinLat = int64(v)
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MaxLat = int64(v)
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("min_lon")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("max_lon")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("min_lat")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("max_lat")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Change) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &OSM{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modify == nil {
				m.Modify = &OSM{}
			}
			if err := m.Modify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &OSM{}
			}
			if err := m.Delete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &OSM{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeysVals = append(m.KeysVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bounds == nil {
				m.Bounds = &Bounds{}
			}
			if err := m.Bounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseNodes == nil {
				m.DenseNodes = &DenseNodes{}
			}
			if err := m.DenseNodes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ways = append(m.Ways, &Way{})
			if err := m.Ways[len(m.Ways)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lat = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lon = int64(v)
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lat")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lon")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetId", wireType)
			}
			m.ChangesetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangesetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
			m.UserSid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserSid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Visible = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Committed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseNodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Ids = append(m.Ids, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Ids = append(m.Ids, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseInfo == nil {
				m.DenseInfo = &DenseInfo{}
			}
			if err := m.DenseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lats = append(m.Lats, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lats = append(m.Lats, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lats", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lons = append(m.Lons, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lons = append(m.Lons, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lons", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeysVals = append(m.KeysVals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeysVals = append(m.KeysVals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysVals", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Versions = append(m.Versions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Versions = append(m.Versions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Timestamps = append(m.Timestamps, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Timestamps = append(m.Timestamps, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamps", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.ChangesetIds = append(m.ChangesetIds, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.ChangesetIds = append(m.ChangesetIds, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetIds", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UserSids = append(m.UserSids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UserSids = append(m.UserSids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSids", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Visibles = append(m.Visibles, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Visibles = append(m.Visibles, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibles", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Committeds = append(m.Committeds, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Committeds = append(m.Committeds, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Committeds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Way) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Way: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Way: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Refs = append(m.Refs, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Refs = append(m.Refs, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseMembers == nil {
				m.DenseMembers = &DenseMembers{}
			}
			if err := m.DenseMembers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Updates == nil {
				m.Updates = &DenseMembers{}
			}
			if err := m.Updates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Refs = append(m.Refs, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Refs = append(m.Refs, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
		case 10:
			if wireType == 0 {
				var v Relation_MemberType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Relation_MemberType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Relation_MemberType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Relation_MemberType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseMembers == nil {
				m.DenseMembers = &DenseMembers{}
			}
			if err := m.DenseMembers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Updates == nil {
				m.Updates = &DenseMembers{}
			}
			if err := m.Updates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseMembers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseMembers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseMembers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Indexes = append(m.Indexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Indexes = append(m.Indexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Versions = append(m.Versions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Versions = append(m.Versions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Timestamps = append(m.Timestamps, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Timestamps = append(m.Timestamps, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamps", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.ChangesetIds = append(m.ChangesetIds, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.ChangesetIds = append(m.ChangesetIds, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Orientation = append(m.Orientation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Orientation = append(m.Orientation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Orientation", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lats = append(m.Lats, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lats = append(m.Lats, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lats", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lons = append(m.Lons, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lons = append(m.Lons, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lons", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOsm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOsm
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOsm(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOsm = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOsm   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("osm.proto", fileDescriptorOsm) }

var fileDescriptorOsm = []byte{
	// 1052 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xbf, 0x6e, 0x1b, 0xc7,
	0x13, 0xe6, 0xde, 0x1d, 0xc9, 0xbb, 0x21, 0x65, 0xcb, 0x0b, 0xc1, 0xbf, 0xc5, 0x2f, 0x0e, 0xc5,
	0x9c, 0x02, 0x98, 0x80, 0x21, 0x39, 0x60, 0x91, 0x5e, 0x8a, 0x5d, 0x08, 0xb0, 0x24, 0xe0, 0x24,
	0x44, 0x48, 0x1a, 0xe2, 0xc8, 0x5d, 0xd1, 0x87, 0xf0, 0x6e, 0x89, 0xdb, 0x95, 0x23, 0xf6, 0x79,
	0x80, 0xf4, 0x79, 0x85, 0x3c, 0x42, 0x1e, 0xc0, 0x65, 0xba, 0x74, 0x41, 0xa0, 0x14, 0x41, 0xaa,
	0x94, 0x69, 0x52, 0x04, 0x3b, 0x7b, 0xff, 0xc8, 0xf8, 0x4f, 0x9c, 0xc2, 0x1d, 0xf7, 0x9b, 0x6f,
	0xf6, 0x66, 0xbf, 0xf9, 0x66, 0x08, 0x81, 0x54, 0xe9, 0xc1, 0x32, 0x97, 0x5a, 0x52, 0x57, 0xaa,
	0xf4, 0xff, 0xfb, 0xf3, 0x44, 0x3f, 0xbf, 0x9e, 0x1e, 0xcc, 0x64, 0xfa, 0x78, 0x2e, 0xe7, 0xf2,
	0x31, 0xc6, 0xa6, 0xd7, 0x57, 0x78, 0xc2, 0x03, 0xfe, 0xb2, 0x39, 0xe1, 0x4f, 0x0e, 0x04, 0x9f,
	0x3d, 0x8f, 0xb3, 0xb9, 0x50, 0x42, 0xd3, 0x1d, 0x70, 0x12, 0xce, 0xc8, 0x90, 0x8c, 0xdc, 0x23,
	0xef, 0xe5, 0xcf, 0xbb, 0x24, 0x72, 0x12, 0x4e, 0xef, 0x83, 0xf7, 0x95, 0x58, 0x29, 0xe6, 0x0c,
	0xdd, 0xd1, 0xd6, 0x91, 0xb3, 0x4d, 0x22, 0x3c, 0x1b, 0xfc, 0x45, 0xbc, 0x50, 0xcc, 0xad, 0x71,
	0x73, 0xa6, 0x1f, 0x42, 0xf7, 0x5a, 0x89, 0x7c, 0x92, 0x70, 0xd6, 0x1e, 0x92, 0x51, 0xbb, 0xb8,
	0xaa, 0x63, 0xc0, 0x63, 0x4e, 0x77, 0xc1, 0xc7, 0xb0, 0x4a, 0x38, 0xeb, 0x0c, 0xc9, 0x68, 0xab,
	0x88, 0x63, 0xd2, 0x79, 0xc2, 0xe9, 0x1e, 0xc0, 0x2c, 0x17, 0xb1, 0x16, 0x7c, 0x12, 0x6b, 0xd6,
	0x6d, 0x54, 0x13, 0x14, 0xf8, 0xa1, 0xa6, 0x1f, 0x41, 0x30, 0x5b, 0x48, 0x65, 0x39, 0x7e, 0x83,
	0xe3, 0x5b, 0xf8, 0x50, 0x53, 0x06, 0x9e, 0x5c, 0x8a, 0x8c, 0x05, 0x43, 0x32, 0xf2, 0x8b, 0x28,
	0x22, 0x74, 0x0f, 0x3a, 0x53, 0x79, 0x9d, 0x71, 0xc5, 0x60, 0x48, 0x46, 0xbd, 0x71, 0xef, 0xc0,
	0xa8, 0x78, 0x84, 0x50, 0x54, 0x84, 0x0c, 0x69, 0x86, 0xca, 0xb0, 0x5e, 0x83, 0x64, 0xc5, 0x8a,
	0x8a, 0x10, 0x65, 0xd0, 0x55, 0x3a, 0x4f, 0xb2, 0xb9, 0x62, 0x3b, 0x43, 0x77, 0x14, 0x44, 0xe5,
	0x31, 0xfc, 0x86, 0x40, 0xc7, 0xde, 0x68, 0x04, 0x49, 0x93, 0x6c, 0xb2, 0x90, 0x19, 0x23, 0x43,
	0x67, 0x44, 0xb1, 0x96, 0x56, 0xd4, 0x49, 0x93, 0xec, 0x99, 0xcc, 0x30, 0x1c, 0xdf, 0x60, 0xd8,
	0x59, 0x0b, 0xc7, 0x37, 0x65, 0xd8, 0x64, 0xc7, 0x9a, 0xb9, 0x9b, 0xd9, 0xb1, 0xae, 0xb2, 0x63,
	0xcd, 0xbc, 0xcd, 0xec, 0x58, 0x87, 0xdf, 0x13, 0xe8, 0xd8, 0x9a, 0xe9, 0x10, 0x3a, 0x56, 0x3f,
	0xec, 0x70, 0x6f, 0xec, 0xe3, 0x83, 0xce, 0xce, 0x4f, 0xa2, 0x02, 0x37, 0x8c, 0x54, 0xf2, 0xe4,
	0x6a, 0xc5, 0x9c, 0x4d, 0x86, 0xc5, 0x0d, 0x83, 0x8b, 0x85, 0xd0, 0x82, 0xb9, 0x9b, 0x0c, 0x8b,
	0xd3, 0x10, 0xba, 0x33, 0x99, 0x69, 0x71, 0x63, 0xea, 0x59, 0xa7, 0x94, 0x81, 0x37, 0xa8, 0xb6,
	0x07, 0xde, 0x45, 0x3c, 0x57, 0xf4, 0x03, 0x08, 0x8c, 0xc7, 0x26, 0x68, 0x30, 0x82, 0x1c, 0xdf,
	0x00, 0x9f, 0xc7, 0x0b, 0x15, 0xde, 0x12, 0x70, 0xcf, 0xce, 0x4f, 0x1a, 0x6d, 0x24, 0xaf, 0x6f,
	0xe3, 0x2e, 0xb4, 0x33, 0xc9, 0x85, 0xb5, 0x6f, 0x6f, 0x1c, 0x20, 0xe7, 0x54, 0x72, 0x11, 0x59,
	0x9c, 0x7e, 0x02, 0x3d, 0x2e, 0x32, 0x25, 0x26, 0x96, 0x66, 0xdf, 0x75, 0x17, 0x69, 0x4f, 0x0c,
	0x6e, 0xb8, 0x2a, 0x02, 0x5e, 0xfd, 0xa6, 0x0f, 0xc0, 0xfb, 0x3a, 0x5e, 0x29, 0xe6, 0xe1, 0x8d,
	0xf6, 0x7d, 0x97, 0xf1, 0x2a, 0x42, 0x94, 0x3e, 0x82, 0x20, 0x17, 0x8b, 0x58, 0x27, 0x32, 0x53,
	0xac, 0x8d, 0x94, 0x2d, 0xa4, 0x44, 0x05, 0x1a, 0xd5, 0xf1, 0xa6, 0x12, 0x77, 0xd7, 0x95, 0xf8,
	0x8e, 0x80, 0x67, 0x3e, 0x57, 0x0d, 0xa5, 0x53, 0x58, 0xbc, 0xf5, 0x1f, 0x87, 0xd2, 0x4b, 0xb2,
	0x2b, 0x59, 0xf4, 0xc4, 0xaa, 0x70, 0x9c, 0x5d, 0xc9, 0x08, 0x61, 0x7a, 0x1f, 0xdc, 0x05, 0x0e,
	0x52, 0xed, 0x20, 0x03, 0x20, 0x2e, 0xcd, 0x08, 0x35, 0x71, 0x99, 0x85, 0x7f, 0x12, 0xf0, 0x4c,
	0x3a, 0x1d, 0x40, 0xf7, 0x85, 0xc8, 0x55, 0x82, 0xde, 0x2e, 0x87, 0xbd, 0x15, 0x95, 0x20, 0x0d,
	0x21, 0xd0, 0x49, 0x2a, 0x94, 0x8e, 0xd3, 0x25, 0xba, 0xaa, 0x7c, 0x44, 0x0d, 0xd3, 0x87, 0xd0,
	0x9f, 0x95, 0x3b, 0xc8, 0x6c, 0x0d, 0xb7, 0x41, 0xeb, 0x55, 0x91, 0x63, 0xde, 0xdc, 0x2c, 0x5e,
	0xe3, 0x63, 0xaf, 0xda, 0x2c, 0xed, 0x6a, 0xb3, 0xb4, 0xea, 0xcd, 0x62, 0x8a, 0x4d, 0x54, 0x32,
	0x5d, 0x08, 0xdc, 0x3c, 0xe5, 0x52, 0x28, 0x41, 0x53, 0xec, 0x4c, 0xa6, 0x69, 0xa2, 0xb5, 0xe0,
	0x1b, 0x8b, 0xa7, 0x84, 0xc3, 0x1f, 0x08, 0x40, 0xed, 0x0b, 0xba, 0x03, 0x6e, 0xc2, 0xad, 0x45,
	0x29, 0xca, 0x6d, 0x8e, 0x74, 0x1f, 0xac, 0x5f, 0x26, 0xa8, 0x79, 0x1b, 0x35, 0xbf, 0x53, 0x5b,
	0x0a, 0x85, 0x0f, 0x78, 0xf9, 0xd3, 0x34, 0x6d, 0x11, 0x6b, 0xc5, 0xfc, 0xea, 0x16, 0x3c, 0x23,
	0x6e, 0x5c, 0x14, 0x34, 0x70, 0xe3, 0x9a, 0xdd, 0xe6, 0x74, 0x40, 0xd5, 0xe9, 0x6a, 0x42, 0xde,
	0x60, 0xab, 0xbf, 0x08, 0x04, 0x55, 0x0d, 0x74, 0x00, 0x7e, 0xd1, 0x28, 0xfb, 0x84, 0xb6, 0xbd,
	0xa7, 0xc4, 0x68, 0x08, 0x50, 0xb5, 0xc9, 0x7a, 0xcd, 0x96, 0xd1, 0x40, 0xe9, 0x43, 0xd8, 0x6a,
	0x76, 0xcf, 0x5a, 0xcf, 0xd2, 0xfa, 0x8d, 0xe6, 0x19, 0x0b, 0xfa, 0x45, 0xf7, 0xec, 0xe8, 0xdc,
	0x43, 0x4e, 0xd7, 0x36, 0x0f, 0x1f, 0x55, 0x76, 0xcf, 0xce, 0x8d, 0x8d, 0xfb, 0x45, 0xf3, 0x14,
	0x16, 0x6b, 0x1b, 0xa5, 0x58, 0x67, 0xe8, 0x8e, 0xfc, 0xa2, 0xd8, 0x02, 0x33, 0xc5, 0x56, 0x6d,
	0x52, 0xac, 0x5b, 0x17, 0x5b, 0xa3, 0xe1, 0x6f, 0x04, 0xdc, 0xcb, 0x78, 0xf5, 0xbe, 0x86, 0xca,
	0xcb, 0xc5, 0xd5, 0x5a, 0x5b, 0xcd, 0x99, 0x7e, 0x0a, 0x5b, 0xd6, 0x1d, 0xa9, 0x48, 0xa7, 0x22,
	0x57, 0xf8, 0x0f, 0xd5, 0x1b, 0xdf, 0xab, 0x0d, 0x72, 0x62, 0x03, 0x51, 0x9f, 0x37, 0x4e, 0xf4,
	0x11, 0x74, 0xaf, 0x97, 0x3c, 0xd6, 0xa2, 0xfc, 0xdf, 0x7a, 0x45, 0x46, 0xc9, 0x08, 0x7f, 0x77,
	0xc0, 0x2f, 0x37, 0xce, 0xfb, 0x79, 0x2e, 0x83, 0x76, 0x2e, 0x4d, 0x73, 0xfc, 0x2a, 0xcf, 0x02,
	0x95, 0x10, 0xc1, 0x86, 0x10, 0x63, 0x68, 0xeb, 0xd5, 0x52, 0x58, 0x0f, 0xdf, 0x19, 0xb3, 0xb5,
	0x35, 0x79, 0x60, 0x9f, 0x74, 0xb1, 0x5a, 0x0a, 0x7b, 0x17, 0x52, 0xff, 0x29, 0x5e, 0xef, 0x9d,
	0xc5, 0xeb, 0xbf, 0x55, 0xbc, 0x7d, 0x80, 0xfa, 0xeb, 0xd4, 0x07, 0xef, 0xf4, 0xec, 0xc9, 0xd3,
	0xed, 0x16, 0xed, 0x82, 0x7b, 0x79, 0xf8, 0xc5, 0x36, 0xa1, 0x7d, 0xf0, 0xa3, 0xa7, 0xcf, 0x0e,
	0x2f, 0x8e, 0xcf, 0x4e, 0xb7, 0x9d, 0xf0, 0x0f, 0x02, 0xfd, 0xe6, 0x45, 0xf4, 0x01, 0x74, 0x93,
	0x8c, 0x8b, 0x1b, 0x61, 0xc7, 0xaa, 0x70, 0x7a, 0x01, 0xad, 0x4d, 0x9d, 0xf3, 0xd6, 0xa9, 0x73,
	0xff, 0xdd, 0xd4, 0x79, 0xaf, 0x99, 0xba, 0x8f, 0xa1, 0x27, 0xf3, 0x44, 0x64, 0x1a, 0x45, 0x6d,
	0x0c, 0x56, 0x13, 0x7e, 0xd7, 0x0d, 0x74, 0xf4, 0xbf, 0x97, 0xb7, 0x03, 0xf2, 0xe3, 0xed, 0x80,
	0xfc, 0x72, 0x3b, 0x20, 0xdf, 0xfe, 0x3a, 0x68, 0x7d, 0xd9, 0x96, 0x2a, 0x5d, 0x4e, 0xff, 0x0e,
	0x00, 0x00, 0xff, 0xff, 0xe7, 0xfa, 0x61, 0xd6, 0x90, 0x0a, 0x00, 0x00,
}
